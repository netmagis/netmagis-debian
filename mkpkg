#!/bin/sh

#
# Build Debian package and test package installation with the help of Docker
#
# Usage:
#    mkpkg netmagis-src-dir netmagis-debian-dir gpg-keyid [action ...]
#
# Example:
#    cd netmagis-debian
#    ./mkpkg ../netmagis . debian-packages@netmagis.org image build test clean
#    # packages are created in netmagis-debian-dir
#
#
# actions
# - image: create the needed Docker images
# - build: build packages (using the build/ Docker image, which in turn
#	will run the build/run.sh script)
#	Note: the netmagis-<version>.tar.gz must already be generated
#		in netmagis-src-dir
#	Resulting Debian packages are located in netmagis-debian-dir
# - test: test installation of generated debian packages
#	Note: even if not used, the netmagis-src-dir arg must be supplied 
#	Note: Debian packages are assumed to be located in netmagis-debian-dir
# - clean: remove the Docker images
#

#
# Memo for essential Docker commands
#   docker build <dir>
#   docker container ls -a
#   docker container stop <cont-id>
#   docker image ls
#   docker image rm <img-id>
#   docker run ... --interactive --tty <tag> /bin/sh
#

set -e
set -u

TAG_BUILD=nmbuild
TAG_TEST=nmtest

# $1: msg to display
usage ()
{
    (
	echo "usage: $0 netmagis-src-dir netmagis-debian-dir gpg-keyid [action ...]"
	if [ $# != 0 ]
	then echo "$1"
	fi
    ) >&2
    exit 1
}

# $1: directory path, may be relative
absdir ()
{
    if [ ! -d "$1" ]
    then usage "directory '$1' must already exist"
    fi
    ( cd "$1" ; pwd)
}

##############################################################################
# Build images
#
# Use the file "Dockerfile" in the appropriate directories
# and build an image labelled with the tag so that we can find them easily

image_build ()
{
    local DESTDIR="$NMDEB/tmp"
    rm -rf "$DESTDIR"
    mkdir "$DESTDIR"
    gpg --export --output "$DESTDIR"/pub.key "$KEYID"
    gpg --export-secret-key --output "$DESTDIR"/priv.key "$KEYID"
    docker build --tag=$TAG_BUILD $NMDEB/build
}

image_test ()
{
    docker build --tag=$TAG_TEST  $NMDEB/test
}

##############################################################################
# Docker run
#

# $1: tag
# $2: "interactive" or ""
docker_run ()
{
    local tag=$1
    local inter=$2
    local pre= post=

    if [ "$inter" = "interactive" ]
    then
	pre="--tty --interactive"
	post="/bin/bash"
    fi

    docker run \
	    --rm=true \
	    --env=DESTUID=$(id -u) \
	    --env=DESTGID=$(id -g) \
	    --env=KEYID="$KEYID" \
	    --mount "type=bind,source=$NMSRC,target=/nmsrc" \
	    --mount "type=bind,source=$NMDEB,target=/nmdeb" \
	    $pre $tag $post
    if [ $? != 0 ]
    then echo "Abort" >&2 ; exit 1
    fi
}

run_build ()
{
    docker_run $TAG_BUILD ""
}

run_test ()
{
    docker_run $TAG_TEST ""
}

##############################################################################
# Clean images
#
# Use the file "Dockerfile" in the appropriate directories
# and build an image labelled with the tag so that we can find them easily

clean_build ()
{
    docker image rm $TAG_BUILD
}

clean_test ()
{
    docker image rm $TAG_TEST
}


if [ $# -lt 3 ]
then
    usage
    exit 1
fi

NMSRC="$(absdir "$1")"
NMDEB="$(absdir "$2")"
KEYID="$3"

# Check the PGP key (script aborts if this command returns an error)
gpg --list-keys "$KEYID" > /dev/null

#
# Test arguments
#

shift 3

if [ $# = 0 ]
then
    set image build test clean
fi

for action
do
    case x"$action" in
	ximage)				# prepare both images
	    image_build
	    image_test
	    ;;
	ximage_build)			# prepare "build" image
	    image_build
	    ;;
	ximage_test)			# prepare "test" image
	    image_test
	    ;;
	xkey)				# export key from personal account
	    prepare_key
	    ;;
	xrun)				# run both images
	    run_build
	    run_test
	    ;;
	xrun_build)			# run "build" image
	    run_build
	    # packages are located in $NMDEB directory on output
	    ;;
	xrun_test)			# run "test" image
	    ;;
	xsh_build)			# interactive sh in "build" image
	    docker_run $TAG_BUILD "interactive"
	    ;;
	xsh_test)			# interactive sh in "test" image
	    docker_run $TAG_TEST "interactive"
	    ;;
	xclean)				# clean both images
	    clean_build
	    clean_test
	    ;;
	xclean_build)			# clean "build" image
	    clean_build
	    ;;
	xclean_test)			# clean "test" image
	    clean_test
	    ;;
	*)
	    usage "action=image, run or clean [or see mkpkg file]"
	    ;;
    esac
done
